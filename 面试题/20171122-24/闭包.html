<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>

    <ul id="ul1">
        <li>item 1</li>
        <li>item 2</li>
        <li>item 3</li>
    </ul>
    <button id="btn">点击</button>
<script>
//    function outer(){//外部函数
//        var a = 5;
//        function inner(){//内部函数
//            return a;
//        }
//        return inner;
//    }
//    var fn = outer();
//    console.log(fn());//5 没有被释放

//    (function outer(){//外部函数
//            var a = 5;
//            function inner(){//内部函数
//                return a;
//            }
//            return inner;
//        })();



//    var oUl = document.getElementById('ul1');
//    var aLi = oUl.getElementsByTagName('li');
//    for(var i=0;i<aLi.length; i++){
//        (function(idx){
//            aLi[i].onclick = function(){
//                alert(idx);//不是立即调用
//            }
//        })(i);//函数声明和调用
//        //每一次循环内部idx这个形参都会引用外部的idx
//        //而且不会释放
//        //每次循环i的值都会传给外部idx
//
    }

    //点击按钮，两秒后弹出haha

    var oBtn = document.getElementById('btn');
    oBtn.onclick = function(){
        var str = 'haha';
        setTimeout(function(){
            alert(str);
        },2000);//按理说点击完会立即释放不会弹出，所以是闭包
    };

    /*就是在函数的内部，再定义一个函数。
     　　function f1(){
     　　　　var n=999;
     　　　　function f2(){
     　　　　　　alert(n); // 999
     　　　　}
     　　}
     在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。
     但是反过来就不行，f2内部的局部变量，对f1就是不可见的。
     这就是Javascript语言特有的"链式作用域"结构（chain scope），
     子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，
     对子对象都是可见的，反之则不成立。

     * */











</script>
</body>
</html>