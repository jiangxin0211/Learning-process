https

30、HTTP协议、响应头、请求头：

HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。
它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，
以及哪部分内容首先显示(如文本先于图形)等 。

HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。
HTTP是一个无状态(无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，
则它必须重传，这样可能导致每次连接传送的数据量增大)的协议。

HTTP请求类型有八种：

OPTIONS - 返回服务器针对特定资源所支持的HTTP请求方法。

HEAD- 向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。
这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。

GET - 向特定的资源发出请求。

POST - 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。

DELETE - 请求服务器删除Request-URI所标识的资源。

TRACE- 回显服务器收到的请求，主要用于测试或诊断。

CONNECT - HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。

PATCH - 用来将局部修改应用于某一资源，添加于规范RFC5789。

主要是GET和POST方式：它们二者的区别是：
（1）使用GET请求时，参数在URL中能显示出来；而POST请求则不显示；前者可能存在安全性问题；
（2）使用GET请求发送数据量小，POST则发送请求量大；
（3）GET请求发送请求后会被缓存，POST则为never cached;

响应头

设置响应头最常用的方法是HttpServletResponse的setHeader，该方法有两个参数，分别表示应答头的名字和值。

响应头第一行也称为状态行，格式如下：

HTTP-Version 空格 Status-Code 空格 Reason-Phrase CRLF

HTTP- Version表示HTTP版本，例如为HTTP/1.1。Status- Code是结果代码，用三个数字表示。Reason-Phrase是个简单的文本描述，解释Status-Code的具体原因。Status-Code用于机器自动识别，Reason-Phrase用于人工理解。Status-Code的第一个数字代表响应类别，可能取5个不同的值。后两个数字没有分类作用。Status-Code的第一个数字代表响应的类别，后续两位描述在该类响应下发生的具体状况，具体请参见：HTTP状态码 。

Status-Code的第一个数字定义响应的类别，后两个数字没有分类的作用。第一个数字可 能取5个不同的值： 
1xx:信息响应类，表示接收到请求并且继续处理 
2xx:处理成功响应类，表示动作被成功接收、 理解和接受 
3xx:重定向响应类，为了完成指定的动作，必须接受进一步处理 
4xx:客户端错误，客户请求包含语法错 误或者是不能正确执行 
5xx:服务端错误，服务器不能正确执行一个正确的请求 
101Swiching Protocols
切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议
200OK
请求成功。一般用于GET与POST请求
304Not Modified
未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。
客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
404Not Found
服务器无法根据客户端的请求找到资源（网页）。
通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面
500Internal Server Error
服务器内部错误，无法完成请求

响应头域
服务器需要传递许多附加信息，这些信息不能全放在状态行里。
因此，需要另行定义响应头域，用来描述这些附加信息。响应头域主要描述服务器的信息和Request-URI的信息。

请求头：
HTTP客户程序（例如浏览器），向服务器发送请求的时候必须指明请求类型（一般是GET或者POST）。
如有必要，客户程序还可以选择发送其他的请求头。大多数请求头并不是必需的，但Content-Length除外。
对于POST请求来说Content-Length必须出现。有transfer-encoding字段，就表明回应将由数量未定的数据块组成。
最常用的请求头有：
Cookie：这是最重要的请求头信息之一；
Accept-Charset：浏览器可接受的字符集；
Host：初始URL中的主机和端口；
User-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。


get/post区别

请求参数：get参数附在URL后面?隔开，POST参数放在包体中
大小限制：GET限制为2048字符，post无限制
安全问题：GET参数暴露在URL中，不如POST安全
浏览器历史记录：GET可以记录，POST无记录
缓存：GET可被缓存，post无
书签：GET可被收藏为书签，post不可
数据类型：GET只能ASCII码，post无限制

http：是一个无状态的面向连接的协议
HTTP 超文本传输协议，该协议用来从万维网服务器传输超文本到本地浏览器；
hTTP协议的主要特点可概括如下：
1.支持客户/服务器模式。
2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。
请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。
由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
4.无连接：无连接的含义是限制每次连接只处理一个请求。
服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。
缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。
另一方面，在服务器不需要先前信息时它的应答就较快。



http流程
1.打开HTTP连接。一定要记住HTTP是一种无状态协议。正因为如此，对于每一个请求你都要建立一个新的连接。
2.初始化方法请求。这里面将包含一些类型的方法指示符用来描述调用什么方法和方法所需要的参数。
3.设置HTTP请求头。这里面包含要传送的数据类型(二进制)和数据的总长。
4.发送请求。将二进制流写到服务器。
5.读取请求。目标servlet程序将被调用并接受HTTP请求数据。servlet程序就调用所有必要的参数选择相应的方法。注意，如果这是这个客户端的第一次请求，一个服务器对象的新的实例就会被创建。
6.调用方法。方法将会被服务器端的对象调用。
7.初始化方法响应。如果调用的方法抛出一个异常，客户将接收到出错信息。否则，返回的类型(如果有)将会被发送。
8.设置HTTP响应头。在响应头中，一定会设置待发送数据的类型和长度。
9.发送响应。二进制数据流将从Web服务器发送并返回给客户端。
10.关闭连接。
HTTP 超文本传输协议，该协议用来从万维网服务器传输超文本到本地浏览器；
 
HTTP状态码：
200 : 请求成功
301 : 网页被永久转移到其它URL
404 : 请求的网页不存在
500 : 内部服务器错误
输入域名(url)-->DNS映射为IP-->TCP三次握手-->HTTP请求-->HTTP响应-->
(浏览器跟踪重定向地址)-->服务器处理请求-->服务器返回一个html响应-->
(视情况决定释放TCP连接)-->客户端解析HTML-->获取嵌入在HTML中的对象重新发起http请求
client----->server:SYN(发起一个TCP连接，同步报文)

server----->client:SYN+ACK(应答报文，表示已创建连接)

client----->server:ACK(应答报文，表示收到已连接)

四次挥手：
    由客户端发起的关闭连接
        * client----->server:FIN(请求关闭连接)
        * server----->client:ACK(收到了连接，但不会立即关闭，等到报文都发送完再回复一个FIN)
        * server----->client:FIN
        * client----->server:ACK(收到关闭)

    由服务端发起的关闭连接
        * 当http设置了keepalive定时关闭，服务端会在结束数据传送后关闭TCP连接
http请求

请求行

请求头

空行

请求包体(只有POST请求有包体)


http响应

状态行

响应头

响应包体

http状态码

1XX：表示可续发请求

2XX：表示成功

* 202成功
* 204成功 不返回实体主体
* 206成功 执行了一个范围请求
3XX：表示重定向

* 301永久重定向，增加SEO排名
* 302临时重定向 禁止POST变为GET
* 303另外一个URI
* 304判断是否要更新缓存 请求头部携带if-modified-since自从上次更新距这次多久
* 307临时重定向
4XX：表示客户端错误

* 400客户端语法错误
* 401请求未经授权
* 403服务器拒绝服务
* 404请求资源不存在
5XX：服务端错误

* 500不可预期的错误
* 503此时不能提供服务 稍后恢复正常
释放TCP连接

header中的connecton:close

服务器主动关闭TCP连接，客户端被动关闭连接
header中的connecton:keepalive

连接保持一段时间，可以连续发送http请求


短连接：client方与server
    连接->传输数据->关闭连接    P2P通信
    HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。
    也可以这样说：短连接是指SOCKET连接后发送后接收完数据后马上断开连接。
长连接：
     连接->传输数据->保持连接 -> 传输数据-> 。。。 ->关闭连接。  c/s通信
    长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。
区别：二者所应用的具体场景不同。短连接多用于操作频繁、点对点的通讯，且连接数不能太多的情况。数据库的连接则采用长连接。
http的长连接：
    HTTP也可以建立长连接的，使用Connection:keep-alive，HTTP 1.1默认进行持久连接。HTTP1.1和HTTP1.0相比较而言，
最大的区别就是增加了持久连接支持(貌似最新的 http1.0 可以显示的指定 keep-alive),但还是无状态的，或者说是不可以信任的。


 Socket是什么呢？
 
    Socket是应用层与TCP/IP协议族通信的中间软件抽象层，一组接口，把复杂的TCP/IP协议族隐藏在Socket接口后面。
 
   所以HTTP就是TCP/IP应用层的协议。Socket是他们的软件抽象层。
   // 创建一个Socket实例
var socket = new WebSocket('ws://localhost:8080'); 
// 打开Socket
socket.onopen = function(event){
	// 发消息
  	socket.send('I am the client and I\'m listening!'); 
  	// 收消息
	socket.onmessage = function(event) { 
    	console.log('Client received a message',event); 
	}; 
	// 关闭Socket.... 
  	//socket.close()
};

enctype="multipart/form-data"
TCP/IP是什么？
 
   TCP/IP是个协议组，可分为三个层次：网络层、传输层和应用层。
    在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。
    在传输层中有TCP协议与UDP协议。
    在应用层有FTP、HTTP、TELNET、SMTP、DNS等协议
13\Websocket：基于TCP/IP协议的，双向的、全双工的数据连接
           双向的：客户端、服务器端
           全双工：数据的发送与接收，两者同步进行

	首先Websocket是ws协议,但是是基于HTTP协议的，借用了HTTP的协议来完成一部分握手。这段类似HTTP协议的握手请求中，多了几个东西。
	这个就是Websocket的核心了，告诉 Apache 、 Nginx 等服务器：注意啦，我发起的是Websocket协议，快点帮我找到对应的助理处理~不是那个老土的HTTP。

	至此，HTTP已经完成它所有工作了，接下来就是完全按照Websocket协议进行了。

	但是Websocket只需要一次HTTP握手，所以说整个通讯过程是建立在一次连接/状态中，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议，还要查看identity info的信息。

	服务端就可以主动推送信息给客户端啦!>

	在传统的方式上，要不断的建立，关闭HTTP协议，由于HTTP是非状态性的，每次都要重新传输 identity info （鉴别信息），来告诉服务端你是谁。


	long poll：
	 客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。

	其实原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话）
	ajax轮询 需要服务器有很快的处理速度和资源。(速度）long poll 需要有很高的并发

	哦对了，忘记说了HTTP还是一个状态协议。
	通俗的说就是，服务器因为每天要接待太多客户了，是个健忘鬼，你一挂电话，他就把你的东西全忘光了，把你的东西全丢掉了。你第二次还得再告诉服务器一遍。

http缓存:
	GET请求可以被缓存，POST不能被缓存，所以要想在客户端做HTTP的缓存一定要注意使用GET请求！

	If-Modified-Since/Last-Modified
		If-Modified-Since这个是在Request里面的Cache中的信息用来表示本地缓存最后一次被修改的时间，他被发送到服务器并且和Response的Entity中Last-Modified作比较，如果两者的日期一致，那就说明在此期间页面没有任何改动浏览器可以使用本地缓存。（所提到的头域都可以在上面图中找到，大家结合图来看比较清晰）

	If-None-Match/Etag
		If-None-Match是在Request中请求头的第一行，他存储一个字符串（资源在服务器的唯一确定标志）。Etag是Response中Entity中的一个字符串。

	两个也是做比较，相同说明可以使用缓存。

	http协商缓存中：Etag/lastModified完整过程（可以配合上面的HTTP流程理解）：1.客户端请求一个页面（A）。2.服务器返回页面A，并在给A加上一个Last-Modified/ETag。3.客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。4.客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。5.服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。

	那么问题来了为什么要使用两种缓存方式呢？而且从我的截图中可以看到仅有第二种Etag方式
	原因如下：1.如果一些资源定期生成，这种情况下内容没有变化但是服务器的 Last-Modified改变了，导致文件使用不了缓存。2.Last-Modified的日期只能精确到秒从上面截图可以看到，如果在1s内做了修改，那么就会出现误判3.由于If-Modified-Since/Last-Modified这种方式使用时间判断一定要保证服务器和本地的时间的一致。

	Etag是资源在服务器的唯一标识符，能够更加准确的控制缓存。Last-Modified 与 ETag 是可以一起使用的，但是服务器会优先验证 ETag，在一致之后才会判断Last-Modified，判断是否返回304.使用Ctrl+F5 强制刷新页面，可以忽略以上讲的两种缓存策略








	http回应：格式时头信息+一个空行/r/n+数据其中第一行是协议版本+状态码+状态描述

	content-type：1.0规定头信息必须是ASCLL码，后面数据可以是任何格式，用于告诉客户端数据是什么格式。客户端请求的时候可以使用accept字段声明自己可以接受哪些数据格式。

	content-encoding：说明数据的压缩方法。accept-encoding说明自己接受哪些压索方法。	

	由于1.0tcp链接只能发送一个请求数据发送完毕之后链接就关闭，后续的需要新建连接所以1.0性能较差为了解决这个问题有的浏览器使用非标准的connection：keep-alive字段要求服务器不要关闭tcp连接

	&&*&&&&1.1版本引入要求服务器关持久连接，即tcp连接默认不关闭，可以被多个请求复用，客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接，规范做法是发送最后一个请求时，发送connection：close明确服务器关闭tcp连接，目前对于同一个域名大多数的浏览器允许同时建立6个连接。

	管道机制：1.1版本以前是在同一tcp连接中先发a请求，等待服务器回应，收到后在发送b请求，管道机制允许同时发送a和b请求，但是服务器还是按照顺序先回应a在回应b。

	content-length：声明回应的数据长度。1.1可以不使用只要请求或回应的头信息有transfer-encoding字段，就表明回应将由数量未定的数据块组成。
	
	host字段：用来指定服务器域名。
	&&&但是1.1版本在同一个链接里所有通信是按次序进行的出现，只能一个一个处理相应如果有许多请求排队的话就会有 队头堵塞，为了避免这个问题只有两种方法，1.减少请求数，2.同时多开持久连接，这就导致一些优化技巧的出现，比如合并cssjs，域名分片，将图片嵌入css代码

	&&&http2.0是一个彻底的二进制协议，头和数据都是二进制统称为帧，头信息帧和数据帧。。。

	&&多工通信：2.0复用连接的基础上，客户端和浏览器都可以同时发送多个请求和相应，而且不用按照顺序一一对应，这就避免了对头堵塞。

	%&&&&数据流：2的数据包不是按顺序发送的，同一个链接的数据包可能属于不同的回应。2将每个请求或回应的所有数据包成为一个数据流，每个数据流都有一个独一无二的编号id，另外还规定客户端发送的数据流id为奇数，服务器发出的id为偶数。&可以取消数据流，rst_stream，取消数据流，1.1版本取消数据流只能关闭tcp连接，而2版本可以取消某一次请求，同时保证tcp连接还打开着。客户端还可以指定优先级，优先级高的服务器会越早回应。

	&&头信息压缩：http协议是无状态的每次请求都必须附上所有信息，请求的很多字段都是重复的，比如cookie和user-agent，2版本做了优化头信息可以压缩后在发送，另一方面客户端和服务器同时维护一张头信息表，所有字段存入这个表，生成索引号，以后就不发送同样的字段，只发送索引号，这样就提高了速度。

	&&服务器推送：2版本允许服务器未经请求，主动向客户端发送资源，即服务器可以预期到客户端请求网页后很可能会需要请求静态资源，所以就主动把静态资源随着网页一起发给客户端了。



